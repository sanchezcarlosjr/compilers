README file for Programming Assignment 3
========================================

Your directory should now contain the following files:

 build.xml
 PA3.pdf
 cool-manual.pdf
 README
 cool.cup
 bad.cl
 good.cl
 tests/*
 compare-parser.py
 coolc.py
 parser.py
 mycoolc.py
 myparser.py
 runmips.py
 coolc.jar
 trap_handler.mars
 cool-tree.java
 cool-tree.aps
 AbstractSymbol.java
 AbstractTable.java
 BoolConst.java
 CgenClassTable.java	  
 CgenNode.java
 CgenSupport.java
 ClassTable.java
 CoolParser.java
 CoolTokenLexer.java
 Flags.java
 IdSymbol.java
 IdTable.java
 IntSymbol.java
 IntTable.java
 ListNode.java
 Parser.java
 StringSymbol.java
 StringTable.java
 SymbolTable.java
 TokenConstants.java
 TreeConstants.java
 TreeNode.java
 Utilities.java
 *.java			  other generated files

	The build.xml contains targets for compiling and running your
	program. DO NOT MODIFY.
   
	PA3.pdf is the specification of the third programming assignment.
	Please read it carefully.

	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.cup is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the CUP documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	tests is a directory containing ten test cases. DO NOT MODIFY.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).  From
	this file, cool-tree.java is automatically generated by a
	utility that compiles the specification into Java classes for
	constructing tree nodes.  This file is provided for your
	reference.  DO NOT MODIFY.

        TreeNode.java and ListNode.java contain definitions used by the
        tree package. DO NOT MODIFY.  

        Parser.java contains a driver to test the parser. DO NOT MODIFY.

	Flags.java implements routines for parsing command line
	flags. DO NOT MODIFY.

        tests is a directory containing ten test cases with expected outputs.
        DO NOT MODIFY.

        The rest of the files are created as byproducts of `CUP', or
        are internal parser support files.  DO NOT MODIFY.
        `CoolParser.java' is the generated Java file containing the
        parser.  DO NOT MODIFY this file directly; instead, edit
        cool.cup and this file will be regenerated automatically.

	myparser.py and parser.py are a python script driveing the parser.
	compare-parser.py is a python script which compares the outcome
	of your parser with the reference. DO NOT MODIFY.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% ant parser

	To test your parser on a file 'foo.cl' type

	% python myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.  Don't worry if the line numbers you get by
	running Java version of the parser are slightly off as compared
	to the "official" parser.

	To run your parser on the files good.cl and bad.cl type:

	% ant test

        To run ten examples in tests directory type:

        % ant test-all

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% python mycoolc.py foo.cl

        To run the reference parser on a file 'fool.cl':

        % pythone parser.py foo.cl

        To easily compare your parser and the reference parser:

        % python compare-parser.py foo.cl

        This will create a diff file (fool.cl.diff), when two parsers
	disagree.

	To turn in your work type:

	% ant submit-clean

	And run the "submit PA3" program. This will automatically collect the
	files good.cl, bad.cl, good.output, bad.output, README, and cool.cup 
        file. Don't forget to edit this README file to include your write-up, 
        and to write your own test cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------
Since the COOL syntax is in non-pure Backus–Naur form, we first converted it to pure Backus–Naur form.
Given the COOL grammar, its Backus-Naur Naur form is below. Note that EPSILON is null character and whitespaces have got be ignored.

  <program> ::= <class_list>
  <class_list> ::= <class> | <class_list> <class>
  <class> ::= CLASS TYPEID LBRACE <optional_feature_list> RBRACE SEMI
  <class> ::= CLASS TYPEID INHERITS TYPEID LBRACE <optional_feature_list> RBRACE SEMI
  <optional_feature_list> ::= EPISLON | 
                              <optional_feature_list> <method> SEMI |
                              <optional_feature_list> <attr> SEMI
  <method> ::= OBJECTID LPAREN <optional_formal_list> RPAREN COLON TYPEID LBRACE <expr> RBRACE
  <attr> ::= OBJECTID COLON TYPEID <assign_expr>
  <optional_formal_list> ::= EPSILON | <formal_list>
  <formal_list> ::= <formal> | <formal> COMMA <formal_list>
  <formal> ::= OBJECTID COLON TYPEID
  <optional_expr_list> ::= EPSILON | <expr_list>
  <expr_list> ::= <expr> | <expr> COMMA <expr_list>
  <expr_sentences> ::= <expr> SEMI | <expr_sentences> <expr> SEMI
  <assign_expr> ::= ASSIGN <expr> | EPSILON
  <dispatch_parent> ::= AT TYPEID | EPSILON
  <list_assigns> ::= EPSILON | COMMA OBJECTID COLON TYPEID <assign_expr> <list_assigns>
  <list_cases> ::= <case> | <list_case> <case>
  <case> ::= OBJECTID COLON TYPEID DARROW <expr> SEMI 
  <expr> ::= OBJECTID ASSIGN <expr>
  <expr> ::= <expr> <dispatch_parent> DOT OBJECTID LPAREN <optional_expr_list> RPAREN
  <expr> ::= OBJECTID LPAREN <optional_expr_list> RPARENT
  <expr> ::= IF <expr> THEN <expr> ELSE <expr> FI
  <expr> ::= WHILE <expr> LOOP <expr> POOL
  <expr> ::= LBRACE <expr_sentences> RBRACE
  <expr> ::= LET OBJECTID COLON TYPEID <assign_expr> <list_assigns> IN <expr>
  <expr> ::= CASE <expr> OF <list_cases> ESAC
  <expr> ::= NEW TYPEID
  <expr> ::= ISVOID TYPEID
  <expr> ::= <expr> PLUS <expr>
  <expr> ::= <expr> MINUS <expr>
  <expr> ::= <expr> MULT <expr>
  <expr> ::= <expr> DIV <expr>
  <expr> ::= NEG <expr>
  <expr> ::= <expr> LE <expr>
  <expr> ::= <expr> LT <expr>
  <expr> ::= <expr> EQ <expr>
  <expr> ::= NOT <expr>
  <expr> ::= LPAREN <expr> RPAREN
  <expr> ::= OBJECTID | INT_CONST | STR_CONST | BOOL_CONST

Cool Syntax has its own precedence operators, we only checked out the CUP manual, and write it down.

However, we made subtle changes to grammar because "cool-tree.java" provides a different framework, for example we write the error symbol in production rules. We'll focus on how we solved let ambiguity, the rest of the changes are not big deal.

We didn't solve it by precedence tricks as the assignment suggested. We just made new production productions that works like parser.py where new assigments make up a new tree with previous assigments (let (let (let expr) ) ).

In brief, productions rules are
<expr> ::= LET <let>
<let> ::= <assigments> <let> | <assigments> in <expr>
where <assigments> is a nonterminal pseudovariable that refers assigments.

We added new test cases testing my claims.

